input {
  beats {
    port => 5044
  }
}

filter {
  # Parse SSH log format
  grok {
    match => { 
      "message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:hostname} sshd\[%{POSINT:process_id}\]: %{GREEDYDATA:ssh_message}" 
    }
  }
  
  # Template1 & Template2: Failed password
  if "Failed password" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Failed password for (invalid user )?%{USERNAME:user} from %{IP:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "failed_login" }
      add_tag => [ "security_event", "failed_auth" ]
    }
  }
  
  # Template3: Accepted password
  else if "Accepted password" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Accepted password for %{USERNAME:user} from %{IP:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "successful_login" }
      add_tag => [ "successful_auth" ]
    }
  }
  
  # Template4: Connection closed
  else if "Connection closed by authenticating user" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Connection closed by authenticating user %{USERNAME:user} %{IP:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "connection_closed_preauth" }
      add_tag => [ "security_event", "suspicious_disconnect" ]
    }
  }
  
  # Template5: Too many authentication failures (supporto IPv4 e IPv6)
  else if "Too many authentication failures" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Disconnect from %{IPORHOST:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "brute_force_attempt" }
      add_tag => [ "security_event", "brute_force", "high_priority" ]
    }
  }
  
  # Template6: Maximum authentication attempts exceeded
  else if "maximum authentication attempts exceeded" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "error: maximum authentication attempts exceeded for %{USERNAME:user} from %{IPORHOST:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "brute_force_attempt" }
      add_tag => [ "security_event", "brute_force", "high_priority" ]
    }
  }
  
  # Template7: Did not receive identification string
  else if "Did not receive identification string" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Did not receive identification string from %{IPORHOST:source_ip}" 
      }
      add_field => { "event_type" => "connection_error" }
      add_tag => [ "connection_issue", "possible_scan" ]
    }
  }
  
  # Template8: Reverse mapping failed (spoofing)
  else if "reverse mapping checking" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "reverse mapping checking getaddrinfo for %{IPORHOST:source_ip} failed" 
      }
      add_field => { "event_type" => "possible_spoofing" }
      add_tag => [ "security_event", "spoofing" ]
    }
  }
  
  # Template9: Could not load host key
  else if "Could not load host key" in [ssh_message] {
    add_field => { "event_type" => "configuration_error" }
    add_tag => [ "system_error", "config_issue" ]
  }
  
  # Template10: PAM authentication failure (formato lungo e corto)
  else if "pam_unix" in [ssh_message] and "authentication failure" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => [
          "pam_unix.*user=%{USERNAME:user} rhost=%{IPORHOST:source_ip}",
          "pam_unix.*rhost=%{IPORHOST:source_ip}.*user=%{USERNAME:user}"
        ]
      }
      add_field => { "event_type" => "auth_failure" }
      add_tag => [ "security_event", "pam_failure" ]
    }
  }
  
  # Template11: Invalid user
  else if "Invalid user" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Invalid user %{USERNAME:user} from %{IP:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "invalid_user" }
      add_tag => [ "security_event" ]
    }
  }
  
  # Template12: Failed publickey
  else if "Failed publickey" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Failed publickey for %{USERNAME:user} from %{IP:source_ip} port %{POSINT:source_port}" 
      }
      add_field => { "event_type" => "failed_publickey" }
      add_tag => [ "security_event", "failed_auth" ]
    }
  }
  
  # Port scan template
  else if "port scan" in [ssh_message] {
    grok {
      match => { 
        "ssh_message" => "Connection attempt to port %{POSINT:target_port} from %{IPORHOST:source_ip} for user %{USERNAME:user}" 
      }
      add_field => { "event_type" => "port_scan" }
      add_tag => [ "security_event", "port_scan", "high_priority" ]
    }
  }
  
  # Convert timestamp
  date {
    match => [ "timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss" ]
    timezone => "Europe/Rome"
    target => "@timestamp"
  }
  
  # Convert ports to integers
  mutate {
    convert => { 
      "source_port" => "integer"
      "target_port" => "integer"
      "process_id" => "integer"
    }
  }
  
  # GeoIP solo per IP pubblici IPv4
  if [source_ip] and [source_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|fe80:|2001:0?db8:)/ {
    geoip {
      source => "source_ip"
      target => "geoip"
    }
  } else {
    mutate {
      remove_field => ["geoip"]
    }
  }
  
  # Cleanup
  mutate {
    remove_field => ["log", "agent.ephemeral_id"]
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "ssh-logs-%{+YYYY.MM.dd}"
  }
  
  stdout { 
    codec => rubydebug 
  }
}
